# threadpool
## 目标
1.用于执行大量相对短暂的任务

2.当任务增加的时候能够动态的增加线程池中线程的数量值到达一个阈值

3.当任务执行完毕的时候，能够动态的销毁线程池中的线程

4.该线程池的实现本质上也是生产者与消费者模型的应用。生产者线程向任务队列添加任务，一旦队列有任务到来，如果有等待线程就唤醒来执行任务，如果没有等待线程并且线程数没有达到阈值，就创建线程来执行任务。

## 优点
1.线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。

2.可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃

## 线程中池中线程个数的确定和任务的类型有关系
计算密集型任务，占用CPU较长时间，很少被打断，此时线程池中线程的个数=CPU个数最佳，如果线程个数超过CPU个数，而CPU个数是一定的，这意味着能够并发的数目是一定的，这是就是少量的CPU调度较多的线程，涉及到线程间的切换开销，因为会降低效率。

I/O密集型任务，当执行任务的时候，可能会被I/O中断，也就是线程会被挂起，这种情况线程个数>CPU个数是合理的，假设CPU个数为2，分配的线程个数也为2，此时两个线程都可以执行I/O任务，但是有这种情况是两个线程都阻塞在I/O，这时让出了CPU的控制权，此时如果又来了任务，但是线程个数只有2个，而都处于阻塞，也就没有办法执行，因而对于I/O密集型任务，线程个数要大于CPU个数。

## 工作过程
* 当增加一个任务到线程池，因为线程池的状态是被多个线程共享，所以操作前需要加锁。然后添加任务到任务队列中，也就在添加到单链表中，那么需要线程池中线程去处理这个任务。首先判断线程池中是否有线程空闲，如果有的话，至少一个阻塞在条件变量上的线程。如果当前没有空闲线程，那么判断当前线程池中线程个数是否达到设定的最大值，如果没有，创建一个新的线程。如果此时既没有空闲的线程，而线程池中的线程达到了最大值，那么添加到任务队列中之后什么都不需要做，线程执行完别的任务之后就会执行此任务。  
* 线程的执行函数工作流程：一旦创建一个新的线程出来，那么访问线程池之前需要加锁，将当前的空闲线程数加1。如果此时任务队列为空，并且没有收到线程池销毁的通知，那么condition_timedwait，该函数设置了一个超时时间，到期后会退出当前线程。当等待到了任务，那么将当前的空闲线程数减1，同时取出任务队列的第一个任务，由于任务执行需要消耗时间，先解锁线程池让其他线程访问，执行完毕之后重新加锁。如果等待到线程池销毁通知（通过在threadpool_destroy函数中设置 pool->quit = 1;），且任务执行完毕，那么退出当前线程；  
* 线程池的销毁操作：首先对线程池执行加锁操作，设置销毁标记，如果当前线程池中的线程个数大于0，那么对所用空闲的线程发起广播通知，然后这些空闲线程就会退出。但是处于执行任务的线程没有收到销毁通知，所以执行完任务之后，判断销毁标记是否为1，如果为1，那么将当前的工作线程数减1，如果减为0，就向主线程发起通知，知等待线程（主线程）全部任务已经完成。主线程被唤醒，线程池销毁完毕。  
